# -*- coding: utf-8 -*-
"""EPAi3_assignement7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TPpgR6BirJhlD9PUWyTL9uw_DO3GKEIh
	Name: Thamizhannal Paramasivam
	
	
"""

# Q1. Write a closure that takes a function and then check whether the function 
# passed has a docstring with more than 50 characters. 
# 50 is stored as a free variable (+ 4 tests) - 200

# add_nums() is the method for which doc string length is going to be computed .
def add_nums(num1=0, num2=0):  
  """Summary or Description of the Function
  Function to add two numbers and returns val as int.

  Parameters:
  Argument1: num1 as int value
  Arugment2: num2 as int value

  Returns:
  Returning doc string value .
  """
  add_result = 0
  if num1>=0 and num2 > 0 :
    add_result = num1 + num2
  return add_result

def doc_str_validator(fun):
  """
  summary: validates given fun has > 50 lenght of doc string, if yes returns True otherwise False.
  parameter: it accpets function as parameter.
  
  """
  # max_doc_str_len is free variable
  max_doc_str_len = 50 # Maximul value of doc string

  def check_doc_str_len():
    nonlocal max_doc_str_len
    if len(fun.__doc__) > max_doc_str_len:
      print("{} function does have doc string with > {} charecters.".format(fun.__name__, max_doc_str_len))
      return True
    else:
      print("{} function does not have doc string with > {} charecters.".format(fun.__name__, max_doc_str_len))
      return False
  return check_doc_str_len

fn = doc_str_validator(add_nums)
fn()

# Q2. Write a closure that gives you the next Fibonacci number (+ 2 tests) - 100
# 
# 0 1 1 2 3 5 8 13 21 34 55
# Program to print the fibonacci series upto num_terms

def fib():
  """
  summary: method that generates fibonacci series
  """
  prev_num = 0
  curr_num = 1

  def get_next_fib_number():
    """
    summary: method that generates next number in fibonacci series
    once sum of prev_num and curr_num is computed, curr_num & next_num values are swapped with prev_num & curr_num.
    variables:
    prev_num initialized with value 0
    curr_num initialized with vale 1
    next_num stores sum of prev_num and curr_num
    """
    nonlocal prev_num, curr_num
    next_num = prev_num + curr_num
    prev_num, curr_num = curr_num, next_num
    return next_num

  return get_next_fib_number

def fib_closure(n):
  """
  summary: Wrapper method for fib()
  parameter: n is value in int that represent number of term in fibonacci series.
  """
  fn = fib()
  for i in range(2, n+1):
    num = fn()    
  return num

#fib_closure(10) # Uncomment to run this code


# Q3. We wrote a closure that counts how many times a function was called. 
# Write a new one that can keep a track of how many times add/mul/div functions were called,
# and update a global dictionary variable with the counts (+ 6 tests) - 250

def add(a,b):
  """
  summary: method to add two numbers
  parameters: both parameters should be int values.  
  """
  return a + b

def mult(a,b):
  """
  summary: method to mult two numbers
  parameters: both parameters should be int values.  
  """
  return a*b

def div(a,b):
  """
  summary: method to divide numbers
  parameters: both parameters should be int values.  
  """
  return (a/b)

# global function call counter dictionary
fun_counters = dict()

def functional_counter():
  """
  summary: wrapper function that counts number of times function called
  returns: returns inner function as return value
  """
  #cnt = 0
  counter_dict = dict()
  def inner(fn, *args, **kwargs):
    """
    summary: method increment counter dict every time fun called also update global dict fun_counters.
    parameter: function as parameter(add/mult/div)
    returns: function value as return type
    """
    
    nonlocal counter_dict 
    counter_dict[fn.__name__] = counter_dict.get(fn.__name__, 0) + 1
    fun_counters[fn.__name__] = counter_dict[fn.__name__] 
    return fn(*args, **kwargs)
  return inner

# Uncomment to run this code
"""
# Execution steps:
fn = functional_counter()
fn(add,3,3)
fn(add,3,3)
fn(add,3,3)

fn(mult,3,3)
fn(mult,3,3)


fn(div,9,3)
fn(div,4,2)
print(fun_counters)
"""

# 4. Modify above such that now we can pass in different dictionary variables to 
# update different dictionaries (+ 6 tests) - 250


def functional_counter(custom_dict):
  """
  summary: wrapper function that counts number of times function called
  parameter: dict is parameter
  returns: returns inner function as return value
  """

  def inner(fn, *args, **kwargs):
    """
    summary: method increment custom_dict every time fun called also update global dict fun_counters.
    """
    custom_dict[fn.__name__] = custom_dict.get(fn.__name__, 0) + 1
    return fn(*args, **kwargs)
  return inner
  
# Uncomment to run this code
"""
custom_dict = dict()
fn = functional_counter(custom_dict)
fn(add,3,3)
fn(add,3,3)

fn(div,4,2)
print(custom_dict)

"""